---
title: "AIエージェント連携プロトコル比較 MCP・ACP・A2A・ANPの仕組みと使いどころ"
source: "https://ai-data-base.com/archives/90935"
author:
  - "[[AIDB Research]]"
published: 2025-06-13
created: 2025-06-13
description: "本記事では、MCP、ACP、A2A、ANPという4つの主要なエージェント連携プロトコルを論文ベースで紹介します。"
tags:
  - "clippings"
---
**【お知らせ】** AIDB主催のビジネスマッチングイベントを7月25日(金)開催予定です！  
  

\---以下、記事本文---

本記事では、MCP、ACP、A2A、ANPという4つの主要なエージェント連携プロトコルを論文ベースで紹介します。

LLMエージェントを本格的に活用する場面が増える中で、ツールや外部サービスとのつながり方にも一定の設計が求められるようになってきました。

それぞれのプロトコルには、得意とする連携のスタイルや前提とする運用環境に違いがあります。どれをどう使えばよいのかを考えるうえで、比較の視点を持って整理しておくとよいかもしれません。

![](https://ai-data-base.com/wp-content/uploads/2025/06/AIDB_90935-1024x576.png)

## 背景

LLMエージェントを業務に組み込む流れが進むにつれ、単体で完結するチャット形式の活用から、複数の機能や外部サービスを連携させるようなエージェント構成へと関心が広がってきました。そうした中で注目を集めているのが、MCP（Model Context Protocol）です。ツールとの接続や情報の取り込み方に便利な仕組みとして、技術者の間で徐々に知られるようになってきました。

しかし、MCPの活用が模索されはじめたタイミングで、A2A、ACP、ANPといった新たなプロトコルも次々に登場し、全体像の把握が難しくなっています。どのプロトコルがどんな用途に向いているのか、そもそも何がどう違うのかが見えにくくなっており、開発現場では「導入の手がかりがないまま、複雑さだけが増している」と言っても過言ではありません。

このような混乱を整理する助けになるよう、本記事では論文をもとに各エージェント通信プロトコルを取り上げ、それぞれの設計思想や想定ユースケース、セキュリティモデルなどを横断的に比較していきます。MCP、ACP、A2A、ANPのそれぞれが、どのような連携を目指しているのかを整理した上で、どの段階でどの技術を選ぶべきかといった導入の参考を示します。

LLMエージェントを本格的に検討する今、技術の選択肢が広がること自体は歓迎すべき動きです。まずは、判断軸を明確化していきましょう。

まずは、今回取り上げる4つのプロトコルについて、大まかな位置づけを確認しておきます。

- **MCP** （Model Context Protocol）は、LLMとツールやデータの接続を扱うための仕組みで、エージェントが外部リソースを活用する際の「入り口」の役割を持ちます。
- **ACP** （Agent Communication Protocol）は、異なるシステムやフレームワーク間のやり取りを標準化するための通信方式です。
- **A2A** （Agent-to-Agent Protocol）は、エージェント同士が「誰が何をするか」を話し合いながら、複数で連携できるようにするためのルールです。
- **ANP** （Agent Network Protocol）は、インターネットのような広域な環境でも、信頼関係のあるエージェント連携を実現するための分散型の枠組みです。

それぞれ少しずつ扱っている範囲やレイヤーが異なっており、「似ているようで違う」存在です。どれか一つがすべてを解決するわけではなく、それぞれが異なる現場の悩みに応じて設計されています。

## エージェント同士の連携でなにが課題か

以下では、各プロトコルが対応しようとしている代表的な課題を4つに分けて見ていきます。

### 課題１：LLMに文脈を渡す仕組みが統一されていない

LLMを使ってなにか複雑な処理をさせたいと思ったとき、「どのツールをどう呼び出すのか」「どの情報を渡せばよいか」など、開発者側で決めなければいけないことが意外と多くあります。たとえば社内データベースとつないだり、検索結果を加工して入力に含めたりする場合、それぞれの構成で「文脈」の持たせ方が微妙に違っていて、設計をやり直すたびに仕様が分岐してしまうことも珍しくありません。

やっていることは似ているはずなのに、毎回プロンプトの形式やデータの渡し方、ツールとの結びつけ方が変わる。そんな状態が続くと、どこが再利用できるのかもわからなくなり、場当たり的な設計になっていきます。

こうした散らばりを少しずつ整理する動きとして、MCPのような仕組みが登場しました。ツールやデータセット、 [サンプリング](https://ai-data-base.com/archives/26518 "サンプリング") 条件などを一定の形式で渡せるようにすることで、構成をシンプルに保ちつつ、異なるLLM環境にもつなげやすくすることが目指されています。  
あくまで「全部を標準化する」ものではありませんが、「毎回同じことを一から考える」状況からは抜け出しやすくなります。

### 課題２：フレームワークごとに通信方式が異なる

実際の業務環境では、社内に複数のチームが存在し、それぞれが異なる言語やフレームワーク（たとえばPythonベースのLangChainと、JavaScriptベースの独自LLMエージェント）で開発を進めていることが珍しくありません。こうしたエージェントを連携させたい場合でも、それぞれが独自の通信手順やフォーマットを前提としているため、相互にやり取りさせるには追加のブリッジ処理が必要になります。

たとえば「エージェントAが検索を担当し、エージェントBが要約を行う」といった構成を組もうとするだけでも、それぞれの入力・出力形式を合わせたり、APIの呼び方を変換したりする実装が必要になります。結果として、連携部分の保守性が低下し、エージェントが増えるほど管理が煩雑になります。

こうした際に役立つのがACPです。ACPは、こうしたバラつきを吸収するために、RESTベースの共通インターフェースを提供します。SDKなどの専用ライブラリに依存しない設計となっており、エージェント間でやり取りするメッセージの形式や流れが明確に定義されています。

さらに、非同期通信や、事前に相手を知らなくても動的にエージェントを検出できる仕組みに対応しており、ネットワークや運用形態が異なる環境でも柔軟な連携が可能になります。フレームワークごとに閉じた世界観ではなく、互いを尊重しながら連携できるようにする、いわば「共通言語」の役割を果たします。

### 課題３：エージェントを組み合わせても、うまく役割分担できない

最近では、複数のエージェントを組み合わせて「調査」「要約」「文書生成」といった複数の作業を分担させようとする構成も増えてきました。しかし、いざ実装に取りかかってみると、「どのエージェントが何をできるのかが伝わらない」「誰に何を任せるべきか決められない」といった曖昧さが浮き彫りになります。

仮に通信だけはできたとしても、その先の調整がうまくいかず、結局ひとつのエージェントに処理を集中させてしまうケースも少なくありません。途中経過を共有しながら動かす仕組みもなく、ステップごとの結果を人手でつなぐような状態になりがちです。

こうした「うまく協調できない問題」に対して、エージェント同士が互いの能力や役割を共有できるようにする仕組みを提供するのがA2Aです。あらかじめ定義されたエージェントカードを通じて、動的に誰が何を担うかを判断できるようにし、その場その場での柔軟な連携を支える構成になっています。  
事前に全体フローを決め込まなくても済むため、特に変化の多い業務や実験的な設計との相性が良いと考えられます。

### 課題４：社内では動くのに、ネット上だとうまくつながらない

エージェント構成がある程度形になってくると、次に考えたくなるのは「外のサービスとも連携できないか」という展開です。しかし、ここでまた新たな壁が見えてきます。  
たとえば社内ネットワークでは動作確認できていた構成が、外部のエージェントとは接続できない。あるいは、信頼できる相手かどうかの判断や、データの安全なやり取りの設計が不透明で、一歩を踏み出せない。こうした「ネット越しの連携」に特有の不安は根深く残っています。

そこで、こうした広域連携の障壁を乗り越えるために、分散型ID（DID）や暗号化通信といった仕組みを取り入れて解決を試みる技術がANPです。特定の中央管理に依存せず、各エージェントが自分の身元や能力を宣言できるようにし、オープンなネットワークでも安全に連携できる関係を築こうとするものです。  
「誰がどこにいるかわからない」前提でも、一定のやり取りが成立するように整えようとする発想だと言えます。

## エージェント通信の歴史をふまえて今どこにいるか

エージェント間通信の標準化は、実はかなり昔から模索されてきたテーマです。これまでに登場しては消えていった数々の試みに目を通しておくと、今なぜMCPやA2Aのようなプロトコルが注目されているのかが見えてきます。

### 形式だけが先行した1990年代の試み

KQMLやFIPA-ACLといった古典的なエージェント言語は、今で言う「プロンプトの型」や「やり取りの文法」にあたるものを厳密に定めていました。理論的には魅力的でしたが、実装が重すぎたことで現場ではほとんど使われませんでした。

### 統合の理想が現場に届かなかったSOA時代

2000年代にはSOAやESBなど、業務システムの部品をうまく連携させる構想が広がりました。が、運用が煩雑になりやすく、「設計思想としては美しいが、現実には扱いにくい」という印象を残しました。

### RAGの登場と、それだけでは足りないという気づき

RAGによって、検索と生成をつなげるという発想は一般化しました。ただし、RAGは文脈を与える手段にはなっても、行動の手順を定めるルールまではカバーしていませんでした。「知識は渡せても、どう使うかは決まらない」という状況です。

### LLMエージェント時代の前提と限界

LLMに関数の一覧を渡し、必要に応じて呼び出させるFunction Callingは、一気に実用化を進めました。しかし、定義の再利用が難しかったり、セキュリティまわりが場当たり的だったりと、仕組みとしてはまだ粗いところがあります。

これまでに登場した軽量なLLMエージェントフレームワークを以下にまとめます。

| フレームワーク | 主な特徴 |
| --- | --- |
| CrewAI | 役割分担やサブタスクの委譲、メッセージルーティングを高レベルに抽象化したクルー型 [アーキテクチャ](https://ai-data-base.com/archives/26562 "アーキテクチャ") |
| SmolAgents | 検索・ビジョン・エージェントループの基本機能を単一ファイルで提供する軽量Pythonライブラリ |
| AG2 (AutoGen) | 人手によるチェックポイントやポリシー適用フック、ライフサイクル管理を備えたオープンソースAgentOS |
| Semantic Kernel | セッション跨ぎのメモリ管理・プランニング・プラグイン連携を統合するエンタープライズ向けSDK |
| Swarm | JSON-RPCで並列エージェントを起動・集約するステートレスなマルチエージェントコーディネーション |

以上の流れを簡単に整理するとこうなります。

| 年 | マイルストーン | 主な内容 |
| --- | --- | --- |
| 1993 | KQML | 知識ベースシステム向けに発話行為プリミティブや柔軟なメッセージ構造を導入 |
| 1998 | MASIF | エージェント環境でのサービス登録・発見機能を定義 |
| 2000 | FIPA-ACL | エージェントの心的状態に基づく厳密な意味論と標準的な相互作用プロトコルを規定 |
| 2002 | Webサービス（SOAP/WSDL） | エンタープライズシステムの機能公開、UDDIによるエンドポイント登録を推進 |
| 2006 | ESBパターン | プロトコルブリッジ、メッセージルーティング、変換を通じた統合パターンを確立 |
| 2020 | RAG | 検索と生成を組み合わせ、ベクトル検索結果をLLMに条件付けする手法を一般化 |
| 2023 | Function Calling | LLMがJSON形式でAPI呼び出しを出力し実行できる軽量プロトコルを導入 |
| 2023 | Toolformer | LLM自身がAPI呼び出し箇所を学習し、自律的にツールを活用 |
| 2023 | ReAct | 思考（chain-of-thought）とアクションを交互に行う動的ワークフローを提案 |
| 2024 | MCP | JSON-RPCによる文脈提供とツール連携の標準化を提案 |
| 2024 | ACP | RESTベースの多部構造メッセージとセキュリティ機能を備えた汎用エージェント通信プロトコルを定義 |
| 2024 | ANP | DIDとJSON-LDを使った完全分散型ピアツーピア通信を実現 |
| 2025 | A2A | Agent Cardによる動的発見と成果物中心のエージェント間協調を提案 |

### 現在のプロトコル群が目指していること

これまでの試みをふまえると、いま求められているのは「理論として美しく、かつ現場でも無理なく扱える」通信のかたちです。MCPやACP、A2A、ANPといったプロトコルは、それぞれ異なる視点からこの理想に近づこうとしています。

## MCP（Model Context Protocol）の仕組み

MCPを一言でいうと、LLMと外部のツールやデータソースを効率よく接続するためのプロトコルです。

「AIのためのUSB-C」と表現されることもあり、さまざまなリソースへのアクセスを可能にする共通インターフェースを提供します。Anthropicが2024年11月に発表しました。

### MCPの基本構成

MCPは「クライアント」と「サーバー」の役割を分けた [アーキテクチャ](https://ai-data-base.com/archives/26562 "アーキテクチャ") をとっています。

LLMアプリケーションがクライアントとして動き、ツールやデータを提供する側がサーバーになります。

LLMは必要なときに外部リソースを呼び出し、整った形式で結果を受け取ります。

#### クライアントアプリケーションの役割

クライアントは、MCPのやり取りを始める側として、複数のMCPサーバーとの接続を管理します。セッションの初期化、リソースやツールなどの基本要素のリクエスト、非同期の通知処理などが主な役割です。また、通信エラーやタイムアウトへの対応も求められます。

#### MCPサーバーの役割

サーバーは、LLMが利用できるリソースや操作機能を提供します。文脈データやAPIの提供、再利用可能なプロンプトの管理、テキスト生成の委譲といったかたちで、クライアントのタスク実行を支えます。さらに、セキュリティポリシーの管理や機能の更新通知も担当します。

### 4つの基本機能

MCPサーバーは、次の4つの機能を軸に設計されています。

- LLMが外部のAPIやサービスを自動で呼び出すための仕組みで、モデル自身が必要に応じて実行判断を行う「Tools」
- 社内文書や構造化データなどをクライアント側で選び、文脈情報をLLMに与えることで補完の精度を高める「Resources」
- 会議議事録の作成や技術文書の要約など、繰り返し行う作業を効率化するテンプレートをあらかじめ用意しておく「Prompts」
- テキスト生成の際に温度や長さといった出力条件を細かく調整し、出力品質を保ちながら生成プロセスを管理する「Sampling」

### MCPの接続ライフサイクル

MCPの通信は、導入から終了までの流れを3つの段階に分けて進めます。

#### 初期化

はじめに、クライアントとサーバーが互いに対応する機能や使えるプロトコルのバージョンを確認します。どの機能を使えるかを事前にすり合わせたうえで、クライアントが”準備完了”の通知を送ります。これで本格的なやり取りが始まる状態になります。

#### 運用

次に、初期化で取り決めた内容に基づいて、タスク実行や情報取得などのやり取りが行われます。通信にはJSON形式のメッセージが使われ、時間内に応答が得られないときは、クライアントが「キャンセル」を通知して、無駄な処理を止めることもできます。

#### シャットダウン

やり取りを終えるときは、どちらからでも通信を終了できます。終了処理では、使っていたリソースの後片づけ（タイムアウトの解除や一時データの削除など）を行います。これ以降は、ログの整理などを除いて、新たな通信は発生しません。

### MCPのセキュリティに関する注意点

MCPの導入は便利な反面、安全面での注意も必要です。たとえば、次のようなリスクが想定されます。

- ツールの中身をすり替えてしまうような改ざんリスク
- 通信を通じて認証情報が盗まれる可能性
- 開発中に気づかず余分な権限を持ち続けてしまうケース
- 外部のサービスを装って攻撃を仕掛けるなりすまし
- 本来の設計とは異なるバージョンで動作してしまうズレ

こうしたリスクを減らすためには、いくつかの対策が有効です。たとえば、ソフトウェアの構成を明示的に記録するSBOM、コードや設定の信頼性を保つためのデジタル署名、意図しない入力を防ぐスキーマ検証、認証の仕組みを強化するOAuth 2.1 + PKCEなどが挙げられます。また、外部サービスとのやり取りにおいては、特定の操作だけを許可するシステムコールの制限や、構成ファイルの変更を常に追跡するGitOpsのような運用も役立ちます。

MCPライフサイクルにおけるリスクと対策をまとめます。

| フェーズ | 脅威 | 緩和策 |
| --- | --- | --- |
| 作成 | インストーラのなりすまし | SBOMとデジタル署名の強制、再現可能なビルドの採用 |
|  | サプライチェーンバックドア | CI/CDパイプラインの強化、マニフェスト検証、成果物の整合性チェック |
|  | 名前衝突なりすまし | SigstoreやDIDで一意かつ検証可能なID管理を導入 |
|  | 認証なしハンドシェイク | 相互認証とTLSによる通信検証を徹底 |
| 運用 | ツールポイズニング | スキーマ検証、YARA/RegExフィルタリング、 [セマンティック](https://ai-data-base.com/archives/26143 "セマンティック") ガードの適用 |
|  | 認証情報窃取 | OAuth 2.1 + PKCEの導入、トークンスコープ制限、mTLSの使用 |
|  | サンドボックス脱出 | syscallフィルター、AppArmor、コンテナ強化 |
|  | リモートアクセス制御 | EDR/HIDSによる監視、アウトバウンド通信制限 |
|  | コマンドインジェクション/RCE | 入力サニタイズ、シェル呼び出しの無効化、eval禁止 |
|  | ツール再定義（Rug Pull） | 署名付き・バージョン管理されたマニフェストの使用、改ざん監視 |
|  | クロスサーバー影響 | 名前空間のスコープ管理、呼び出し元検証 |
|  | 可視性欠如 | デバッグモード、有効なメタデータ表示、詳細ログの取得 |
| 更新 | バージョンドリフト | GitOpsでのドリフト検出と自動修復 |
|  | 権限持続 | ロール監査と定期的な認証情報ローテーション |
|  | 設定ドリフト | CVEチェック、自動構成検証 |
|  | 署名なしマニフェスト | 署名検証の徹底、署名なしツールのブロック |

## A2A（Agent-to-Agent Protocol）の仕組み

複数のエージェントが役割を分担しながら、一緒にタスクを進められるようにするための仕組みがA2Aです。Googleが2025年4月に発表し、社内業務やチーム作業の自動化に向けた設計になっています。MCPがLLMと外部ツールをつなぐのに使われるのに対して、A2Aはエージェント同士の連携に焦点を当てています。

### どんな役割があるのか

A2Aのやり取りは、「ユーザー」「クライアントエージェント」「リモートエージェント」という三者で成り立ちます。それぞれにどんな役割があるのかを見ていきます。

はじまりのきっかけを作るのがユーザーです。チャットでAIに頼みごとをしたり、アプリの操作を通じて処理をお願いしたりする立場です。人間に限らず、他のシステムやエージェントがユーザーとして振る舞うこともあります。ただし、ユーザーが直接エージェントに命令を出すことはありません。やり取りはすべてクライアントエージェントを経由します。

クライアントエージェントは、ユーザーの意図を読み取り、どのエージェントに何を頼むかを判断します。まず「Agent Card」という自己紹介カードのようなものを見ながら、条件に合うリモートエージェントを探し出します。次に、タスクの内容をわかりやすく整理して指示を出し、進行状況や成果物の受け渡しも担当します。必要に応じて、通知やリアルタイムのやり取りにも対応します。

タスクを実際に引き受けるのがリモートエージェントです。クライアントエージェントから受け取ったタスクを処理し、結果を返します。得意な分野（スキル）はエージェントごとに異なり、たとえばデータの検索やレポート作成、外部サービスとの連携などが含まれます。どんなことができるか、どうすれば呼び出せるかは、あらかじめ「Agent Card」に書かれています。

### 通信のしかたややり取りの流れ

A2Aでは、即時に反応がほしい場面もあれば、しばらく待っても問題ないケースもあります。たとえば、ユーザーに進行状況をリアルタイムで見せたい場合は、ストリーミング（SSE）を使って少しずつ結果を届けます。一方、モバイルアプリや夜間バッチ処理のように、常につながっていなくてもいい場面では、プッシュ通知で進捗や完了の情報を送る仕組みも用意されています。

やり取りのデータ形式はJSON-RPC 2.0という標準に準拠しており、エージェント間で共通の方法で命令を出したり結果を受け取ったりできます。

### A2Aのライフサイクルと更新

エージェントは、一度作ったら終わりではありません。設計から終了まで、いくつかの段階を経て運用されます。

1. Agent Cardを用意し、通信の受付や認証の仕組みを整える作成段階
2. タスクを受け取り、決められたスキルで処理して成果物を返す運用段階
3. 新しいスキルの追加やセキュリティ強化などが行う更新段階
4. 使っていたリソースを解放し、エージェントの活動をきちんと終わらせる終了段階

### セキュリティ面で気をつけたいこと

A2Aを安全に使うためには、ライフサイクルのどの段階にも注意が必要です。たとえば、偽のAgent Cardを使ったなりすましや、処理中の内容を書き換えるような攻撃、更新ミスによる古いままの動作、終了後の情報漏れといったリスクが考えられます。

こうした問題を防ぐためには、Agent Cardにデジタル署名を付ける、通信にTLSを使う、通知の正当性を確認する、更新内容を記録しておく、終了時にアクセス権を無効化するなど、いくつかの対策が効果的です。

A2Aライフサイクルにおけるリスクと対策について以下にまとめます。

| フェーズ | セキュリティ課題 | 緩和策 |
| --- | --- | --- |
| 作成 | Agent Cardやマニフェストのなりすまし | Agent Cardにデジタル署名を付与し、取得時にチェックサム検証を行うCI/CDパイプラインを強化して不正な挿入を防ぐ |
| 運用 | タスク注入やコマンド偽造 | 通信にTLSを必須化し、JSON Web Signaturesでメッセージを署名スキーマ検証と権限制御トークンの発行を徹底 |
| 運用 | プッシュ通知のハイジャック | 通知チャネルを認証し、セッションごとにストリームを分離送信イベントに署名を付与 |
| 更新 | 未認可機能の注入やバージョンドリフト | 変更不可かつバージョン管理されたマニフェストを使用GitOpsで差分検出と署名付きマニフェスト差分を必須化 |
| 終了 | 孤立リソースや監査ギャップ | シャットダウン時にフックを実装し、認証情報を撤回集中ログで操作履歴を一元管理 |

## ACP（Agent Communication Protocol）の仕組み

複数のLLMエージェントを接続して使おうとすると、開発に使われているフレームワークの違いが障壁になることがあります。ACPは、そうしたエージェント同士が共通のやり方でやり取りできるようにするためのプロトコルです。

IBMが2025年3月に提案した仕組みで、A2Aが社内システムでの連携を前提としているのに対し、ACPは広い場面での通信の標準化を目指しています。

### ACPの仕組みを支える3つの役割

ACPでは、リクエストを送る「クライアント」、それを受けて処理を調整する「サーバー」、実際に動作を実行する「エージェント」という構成になっています。

まず、依頼を出すのが「ACPクライアント」です。たとえば「この資料を要約してほしい」といったタスクを、あらかじめ決められた形式にそってサーバーに送ります。すぐに結果がほしいときにも、あとから返ってきてもいいときにも対応できる仕組みです。

そのリクエストを受け取るのが「ACPサーバー」です。クライアントから届いた依頼を中継し、実際にタスクを処理するエージェントに渡します。あわせて、通信の管理やセキュリティの確保、リソースの見張り役も担います。多数のエージェントが動いている環境でも、安定してつながるように工夫されています。

タスクの本体を実行するのが「ACPエージェント」です。サーバーから受け取った指示を読み取り、手順にそって処理を行い、結果を返します。たとえば文章生成やデータ検索のような作業を、段階的に進めたり、いったん止めてあとから再開したりと、柔軟な対応が可能です。

### やり取りの流れ

やり取りは、まず「どのエージェントに頼むか」を探すところから始まります。エージェントの情報は「Agent Detail」という自己紹介のようなファイルにまとまっていて、決まったURLに置かれていたり、専用の一覧サービスから探せるようになっています。

依頼先が決まったら、クライアントがタスクの指示を送ります。たとえば「この文章を要約してください」という依頼に、関連するファイルやリンクなどをセットにして送信します。これらは「メッセージパーツ」と呼ばれるまとまりで構成されていて、順番や内容の種類も含めて整理されています。

処理が終わると、成果物が返ってきます。要約されたテキストや、生成されたファイルなどです。この成果物は、すぐに別のエージェントに渡して次の処理に使ったり、画面に表示したり、保存しておいたりするのに適した形式で届きます。

### ACPエージェントのライフサイクル

エージェントは次のような流れで運用されます。

1. Agent Detailを作成し、通信方法や認証の手順を整える作成段階
2. クライアントからのタスクに応じて処理を行い、成果物を返す運用段階
3. 機能の追加や設定変更を反映する更新段階
4. 利用が終わったあとに登録情報を整理し、通信を終了させる終了段階

### セキュリティ上の留意点

エージェント間で標準的な通信を行うACPのような仕組みでは、ライフサイクル全体にわたって複数のリスクが考えられます。

たとえば、偽のマニフェストを使ったなりすまし、通信途中での改ざん、認証が適切に行われないままのアクセス、設定ミスによるバージョンの巻き戻し、終了処理の不備による情報残存などが挙げられます。

こうしたリスクに対しては、デジタル署名付きのAgent Detail、TLSやJWSによる通信の保護、短期トークンの利用、セッションIDの管理、操作ログの記録といった対応策が求められます。

以下にまとめます。

| フェーズ | セキュリティ課題 | 緩和策 |
| --- | --- | --- |
| 作成 | メタデータのなりすましやサプライチェーン攻撃 | すべてのマニフェストにデジタル署名を付与し、発見時に整合性を検証CI/CDでの署名チェックと成果物検証を徹底 |
| 運用 | メッセージ改ざんやMITM攻撃 | 通信にTLSを必須化し、各メッセージパーツをJWSで署名 |
| 運用 | 認証欠陥による未認可アクセス | 権限を絞った短期有効トークンを利用し、相互TLSでクライアント認証 |
| 運用 | セッションハイジャックやプライバシー漏洩 | セッションIDを定期的に更新し、保存中コンテキストを暗号化 |
| 更新 | バージョンロールバックや設定ドリフト | 不変かつバージョン管理されたマニフェストを強制GitOpsでのドリフト検出を導入 |
| 終了 | 孤立リソースや監査ギャップ | アクティブタスクを完了または中断し、認証情報を撤回保持ポリシー付きの集中監査ログを整備 |

## ANP（Agent Network Protocol）の仕組み

ここまでのMCP、ACP、A2Aはいずれも、ある程度決まった環境での連携を想定していました。これに対して、ANPは最初からオープンなネットワーク上での協調を視野に入れた設計になっています。つまり、企業の枠を超えて、見知らぬエージェント同士が自律的に出会い、やり取りできる環境をつくることを目指しています。

### 中央に依存しない「分散型」の発想

ANPの根底にあるのは、「中央の管理者がいなくても、安全に協調できるようにする」という考え方です。エージェントはそれぞれ、自分の能力や連携方法を公開しながら、相手が信頼できるかどうかを自分で判断して通信を始めます。

たとえば「誰でも使える検索エージェント」と「どこの誰かよく知らないけれど、専門性の高い翻訳エージェント」が、お互いを見つけて協力する、というような状況をイメージするとわかりやすいかもしれません。

ANPを構成する主な要素は、以下のようなものです。

**エージェントのID管理**

エージェントの身元は「DID（分散型識別子）」で表されます。とくにANPでは「did:wba」という方式を採用しており、HTTPS経由で確認できるようになっています。Webの仕組みをうまく活かしたやり方です。

**エージェントの説明情報**

どんな機能があるのか、どんな通信ができるのか、といった情報は「Agent Description」としてJSON-LDで公開されます。人間にも機械にも読みやすい形式で、エージェントのプロフィールのようなものです。

**発見のためのディレクトリ**

エージェントが存在を示すためには、「.well-known/agent-descriptions」という標準の場所を使って、説明情報を置いておきます。これによって、外部の検索エンジンや他のエージェントがアクセスして、相手を見つけられるようになります。

**通信のインターフェース**

ANPでは、厳密な通信が必要な場面ではJSON-RPCやOpenAPIを使い、もう少し柔らかいやり取りにはYAML形式の「自然言語に近いインターフェース」も使えます。用途に応じて切り替えられる設計です。

**通信内容のすり合わせ機能**

初対面のエージェント同士が、どんな通信プロトコルで話せばいいかをその場で相談できる「メタプロトコル交渉」という仕組みもあります。事前に細かく決めなくても、必要な情報を自然言語で伝え合いながら連携を始められます。

### エージェントのライフサイクル

ANPで動くエージェントは、おおまかに次のような段階を経て運用されます。

1. 最初にDIDを発行し、自分のAgent Descriptionを準備して公開します。これだけで、他のエージェントや検索ツールから見つけてもらえるようになります。
2. 通信時にはDIDに基づく認証が行われ、Agent Descriptionに書かれた内容に沿ってやり取りを進めます。通信形式は、必要に応じてRPC、YAML、リアルタイム接続など柔軟に選べます
3. 能力が変わったときや、連携方法を見直したいときには、Agent Descriptionを更新するだけで済みます。ディレクトリに登録しておけば、自動的に検索対象もアップデートされます。
4. 不要になったエージェントは、DIDの無効化やAgent Descriptionの非公開化によって、安全にネットワークから離脱できます。レジストリに古い情報が残らないような工夫も施されています。

### セキュリティへの配慮

ANPのような分散型システムでは、「誰と通信するか」を自分で判断しなければならない場面が多くなります。そのため、以下のようなポイントで安全性を確保するようになっています。

- 身元のなりすまし対策として、DIDに署名が必要
- 通信内容が改ざんされないよう、インターフェース定義にはハッシュや署名が用いられる
- 更新や終了の際に古い情報が残らないよう、明示的な取り消し信号が使われる

| フェーズ | セキュリティ課題 | 緩和策 |
| --- | --- | --- |
| 作成 | アイデンティティのなりすまし | HTTPSホストのDIDを必須化し、DNSレコードで所有権を検証DID文書の署名検証を徹底 |
| 運用 | 未検証エージェントによる攻撃 | DID公開鍵で認証し、機密操作にはヒューマン認可を要求インターフェース定義に署名を付与し、アクセスログを詳細記録 |
| 運用 | インターフェース改ざん | インターフェース文書に暗号署名を行い、呼び出し元情報を含むログを保存 |
| 更新 | 古い説明情報による混乱 | 定期的なクロールでAgent Descriptionを取得し、既知ハッシュと照合 |
| 終了 | 孤立した識別子の残存 | 有効期限付きDIDを利用し、登録解除時に撤回シグナルを送信 |

## プロトコルの違いをざっくり整理

エージェント同士をつなぐ仕組みMCP、ACP、A2A、ANP、それぞれ得意な構成や使いどころが異なります。

どういった特徴の違いがあるのかをつかみやすくするために、 [アーキテクチャ](https://ai-data-base.com/archives/26562 "アーキテクチャ") や通信形式、発見方法、セッション管理、想定される用途といった観点で整理してみます。

| 項目 | MCP | ACP | A2A | ANP |
| --- | --- | --- | --- | --- |
| [アーキテクチャ](https://ai-data-base.com/archives/26562 "アーキテクチャ") モデル | クライアント・サーバー（JSON-RPC） | ブローカー型クライアント・サーバー（レジストリ＋タスクルーティング） | ピア型（クライアント⇔リモート） | 分散型ピアツーピア |
| 探索方法 | 手動登録・固定URL参照 | レジストリベース | HTTP経由でAgent Card取得 | 検索エンジン的発見 |
| 認証方式 | トークンベース（必要に応じてDID可） | Bearerトークン／相互TLS／JWS | DIDハンドシェイクまたは従来型ヘッダー認証 | 分散型ID（did:wbaなど） |
| メッセージ形式 | JSON-RPC 2.0（Prompts/Tools/Resources） | MIME型付きマルチパート | JSON（Task＋Artifact中心） | JSON-LD（Schema.org/ADP） |
| 中核コンポーネント | Tools, Prompts, Resources, Sampling | Agent Detail, Message, Task Request, Artifact | Agent Card, Task, Message, Artifact | DID文書, Agent Description, Meta-Protocol, 構造化インターフェイス |
| 通信レイヤー | HTTP／Stdio／Server-Sent Events | HTTP（段階的ストリーミング対応） | HTTP＋SSE／Push通知 | HTTPS＋JSON-LD |
| セッション対応 | ステートレス＋ツールコンテキスト継続可 | セッション管理あり | ステートレスまたはセッション管理可 | ステートレス（DID認証トークンで管理） |
| 対象範囲 | LLM⇔外部ツール連携 | フレームワーク横断のエージェント連携 | 信頼された組織内でのタスク委託 | オープンインターネット上での相互接続 |
| 主な用途 | LLMの機能拡張（コード生成や検索） | 汎用的なメッセージ交換 | 企業内ワークフロー自動化 | クロスプラットフォーム連携 |
| 強み | LLMとの密な統合とリソース注入 | マルチモーダル対応／オフライン発見可 | エージェント間交渉と成果物中心の委託方式 | DIDベースの信頼性／AIネイティブな交渉 |
| 制約 | 中央サーバー前提／プロンプト改ざんリスク | レジストリ必須／サーバー制御を強く想定 | 企業カタログ前提の設計 | 交渉オーバーヘッド大／エコシステム未成熟 |

## 少しずつ始めるための導入ステップ

MCP、ACP、A2A、ANPの4つのプロトコルをすべて一度に導入する必要はありません。現実的には、取り組みやすい部分から順に試していくことで、仕組みを無理なく育てていくことができます。ここでは、成熟度や実装のしやすさをふまえて、4つの段階に分けて考えてみます。

### 第1ステップ　ツールとの接続から始める「MCP」

最初に取り組みやすいのが、MCPを使ってLLMから社内ツールやデータベースにアクセスする仕組みです。ここでは「LLMにツールを使わせる」ことに集中します。

たとえば、「社内の顧客データベースから最新の注文を調べて」や「営業資料を要約して」といった指示に対して、LLMが自動でツールを呼び出して回答を返せるようになります。外部APIとの連携や計算ツールとの接続もスムーズに行えます。

従来は設定が煩雑だったツールの使い分けが簡単になり、ひとつのLLMに複数の機能を組み込めるようになります。

### 第2ステップ　ACPで異なるエージェント同士をつなぐ

次のステップは、複数のエージェントを接続する段階です。ここで使うのがACPです。たとえば、Pythonで作った分析エージェントと、JavaScriptで作ったレポート作成エージェントを組み合わせて、「情報収集→分析→報告書の作成」といった一連の流れを自動化できます。

ACPは、通信形式をそろえるためのしくみを提供します。お互いの作りが違っていても、同じルールでやり取りできるようになるので、社内の開発チームが別々に作ったエージェントを組み合わせやすくなります。

また、ストリーミング通信にも対応しているため、処理時間の長いタスクでも進捗を見ながらやり取りできるようになります。

### 第3ステップ　A2Aで協力しながらタスクを進める

次は、エージェントたちが自律的に役割分担しながら仕事を進めていく段階です。A2Aを導入すると、エージェント同士が「誰が何を担当するか」を相談しながら作業を進められるようになります。

たとえば、「市場調査→分析→報告→上司への共有」といった業務の流れを、それぞれ専門のエージェントが受け持ち、自動的に引き継いでいきます。Agent Cardを使って、それぞれのエージェントの得意なことを事前に共有しておくことで、タスクごとに適任者を選ぶことができます。

こうした協調作業は、あらかじめ細かく決めておかなくてもその場で柔軟に進められるため、実際の業務の変化にも対応しやすくなります。

### 第4ステップ　ANPで社外との安全な接続を実現する

最後のステップは、社外のエージェントと連携できる仕組みを整えることです。ANPを使って、社内のエージェントと外部のエージェントが、安全にやり取りできるようにします。

たとえば、自社の購買エージェントが複数のサプライヤーと価格交渉を自動で行ったり、翻訳が必要な場面で外部の専門エージェントに依頼したりといった連携を行います。

ANPでは、分散型のID（DID）を使って信頼性を確保します。特定の管理者に頼らず、やり取りの相手が正当かどうかを相互に確認できるしくみです。

### 負担を抑えながら着実に進めるには

こうした流れを意識して、プロトコルの導入を段階的に進めるのが一つの手です。最初はツール接続のような小さなステップから始め、少しずつ他のエージェントとの連携や、社外との接続へと拡張していきます。

どの段階でも、導入の負担に見合ったメリットが得られます。自社の状況に合わせて無理なく取り組むことを前提に、まずはどこから始めると効果が大きいかを見極めることが最初の一歩になります。

## まとめ

エージェント同士の連携に関する4つのプロトコル、MCP・ACP・A2A・ANPを段階的に紹介してきました。そ

れぞれの仕組みや強み、想定される活用シーンを見比べてみると、どのプロトコルも一長一短があり、目的や導入フェーズに応じて使い分けることが重要だとわかります。

MCPではまずLLMと外部ツールをつなぐ土台を築き、ACPで異なる技術基盤をまたいだ通信を標準化し、A2Aで組織内の役割分担と協調を進め、ANPではより広いネットワークへの接続を目指す。この流れは、いまエージェントの活用を検討している方にとって、段階的に踏み出せる現実的な道筋となります。

LLMエージェントにより複雑なタスクを担わせるには、こうした通信プロトコルの理解は避けて通れないテーマになります。プロンプト設計の先にある、より柔軟で自律的な連携を視野に入れて、ぜひ一歩先の技術選定や設計に活かしていただければと思います。

**参照文献情報**

- タイトル：A survey of agent interoperability protocols: Model Context Protocol (MCP), Agent Communication Protocol (ACP), Agent-to-Agent Protocol (A2A), and Agent Network Protocol (ANP)
- URL： [https://doi.org/10.48550/arXiv.2505.02279](https://doi.org/10.48550/arXiv.2505.02279)
- 著者：Abul Ehtesham, Aditi Singh, Gaurav Kumar Gupta, Saket Kumar
- 所属：Kent State University, Cleveland State University, Youngstown State University, Northeastern University

**■サポートのお願い  
**AIDBを便利だと思っていただけた方に、任意の金額でサポートしていただけますと幸いです。  

  

[「RAGOps」RAGシステムを安定運用するための実践的な考え方の整理](https://ai-data-base.com/archives/90875)

 [![](https://ai-data-base.com/wp-content/themes/innovate_hack_tcd025/img/footer/return_top.png) PAGE TOP](https://ai-data-base.com/archives/#header_top)