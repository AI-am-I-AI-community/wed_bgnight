---
title: "Vibe CodingとAgentic Codingの現在地【前編】～それぞれの特徴～"
source: "https://ai-data-base.com/archives/90427"
author:
  - "[[AIDB Research]]"
published: 2025-05-29
created: 2025-06-13
description: "本記事では、Vibe Coding（バイブコーディング）およびAgentic Coding（エージェンティックコーディング）に関する最新の調査をお届けします。"
tags:
  - "clippings"
---
**【お知らせ】** AIDB主催のビジネスマッチングイベントを7月25日(金)開催予定です！  
  

\---以下、記事本文---

本記事では、Vibe Coding（バイブコーディング）およびAgentic Coding（エージェンティックコーディング）に関する最新の調査をお届けします。

LLMを活用した対話型の開発補助が普及するなかで、自動化を取り入れたワークフローも注目されています。一方で、現場に導入する際には向き不向きの見極めが欠かせません。

それぞれのスタイルにおける活用可能な場面と慎重に扱いたい場面を整理します。

![](https://ai-data-base.com/wp-content/uploads/2025/05/AIDB_90427_top2-1024x576.png)

## 背景

AIを活用した開発支援ツールが身近になり、現場のエンジニアやマネージャーの間では「どのように使いこなすか」が現実的な課題になりつつあります。とくにLLMを用いた支援機能が充実してきたことで、開発プロセスそのものを見直す動きが広がっています。

そうした中で注目を集めているのが「Vibe Coding」という新しいスタイルです。開発者が自然言語で意図や要望を伝え、LLMと対話を重ねながらコードを一緒に組み上げていく方法を指します。コードの構文を直接書くというよりも、「こうしたい」という雰囲気や目的を言葉で伝え、その意図を反映した提案を受け取りながら試行錯誤を重ねる、共同作業に近いスタイルと言えます。

Vibe Codingでは、開発者は実装の細部から距離をとり、全体の設計や方針の調整に注力します。従来のようにIDEに向かって黙々とコードを書くのではなく、LLMとのラリーの中で機能を組み立てていく点が特徴です。

一方で、LLMの自律性にもっと大きく任せた開発スタイルである「Agentic Coding」も登場しています。目標を与えると、それを達成するために必要なタスクを自ら分解・計画し、実行・検証まで行うような、エージェント的な仕組みです。人間の介入は最小限にとどめられ、開発の多くの工程が自動化されるイメージです。

Vibe CodingとAgentic Codingでは、前提とする考え方も、技術の構成も、LLMとの関わり方も大きく異なります。片方は柔軟な協働による創造性に重きを置き、もう一方は構造化された自動実行を志向しています。どちらが優れているという単純な話ではなく、それぞれに適した場面があり、使い分けが問われます。

しかし、実務の中で「どちらのスタイルを採るべきか」「そもそもいずれも向いているのか」こうした判断を行うには、それぞれの特徴や限界を整理して理解しておく必要があります。どのような状況でVibe Codingが力を発揮するのか、どこまでをエージェントに委ねられるのか、そして両者をどう組み合わせられるのか。本記事は、そうした問いに向き合い、この2つの開発スタイルを多面的に比較し、その実用性や可能性を具体的に探っています。

## Vibe CodingとAgentic Coding

Vibe Codingと対比される概念として「Agentic Coding」という言葉も登場しはじめています。以下では、Vibe CodingとAgentic Codingそれぞれの特徴を整理していきます。

なお、Vibe CodingとAgentic Codingのどちらを採るかは、LLMの使い方だけでなく、開発者の役割や思考のしかたによります。繰り返しになりますが、どちらが優れているかではなく、目的や状況に応じてどちらを活用するかを判断することが求められています。

![](https://ai-data-base.com/wp-content/uploads/2025/05/AIDB_90427_1-1024x612.png)

Vibe CodingとAgentic Codingの違いを示す図 会話ベースで進めるスタイルと、自律的に進めるスタイルの対比

### Vibe Codingは「直感をもとにLLMと協働する開発スタイル」

開発者が自然言語で意図を伝え、LLMと対話しながらコードを組み立てていくスタイルがVibe Codingです。たとえば「ログイン機能を作りたい」「ユーザー登録時に2段階認証を入れてほしい」といったリクエストを自然言語で表現し、その意図をLLMがコードとして具現化します。

従来の開発では、頭の中で描いた機能を自らコードに翻訳する必要がありました。Vibe Codingではその工程の多くをLLMに任せることができ、開発者は「何を作るか」に集中できます。

このスタイルにおいては、求められるスキルの種類も変わってきます。文法や記法を細かく覚えるよりも、問題の本質を整理して伝える力や、適切な技術選定、LLMと協働してバージョン管理やデバッグを進めるための判断力が重要になります。

#### Vibe Coding系の代表例

- GitHub Copilot（IDE内でコードの自動補完や提案を行う支援ツール）
- Cursor（対話型エディタで自然言語入力からコード生成を行う）
- Replit Ghostwriter（ブラウザ上のIDEで対話形式のコーディングを可能にする）
- Windsurf（軽量なIDEプラグインとして自然言語からコードを作成する）

なお、本論文には記載がありませんが、Codeium（複数IDEに対応した自然言語ベースの補完ツール）、Amazon Q Developer（AWS環境に特化した会話型支援ツール）も実務で広く利用されています。

#### 開発者に求められる5つの基礎スキル

Vibe Codingを使いこなすには、以下の5つの観点でのスキルがカギになります。

① **思考の整理**  
問題を段階的に分解しながら、LLMが理解しやすい形で意図を伝える力です。課題の核を見極め、ユーザー視点を踏まえ、処理の流れに沿って構造化していく力が問われます。

② **技術選定の視野**  
LLMに任せるとはいえ、どのフレームワークやライブラリが適しているか、基本的な設計パターンの知識があることで、LLMの出力もより現実的になります。

**③バージョン管理と検証**  
LLMの出力は一貫性に欠けることもあるため、細かく状態を保存しながら進めることが重要です。ブランチの使い方次第で、複数のアプローチを安全に試すことができます。

**④協働によるデバッグ**  
エラーが出たときは、単に修正を求めるのではなく、何が起きたのかを説明し、LLMと一緒に原因を探っていく姿勢が求められます。コンテキストが豊富であるほど、LLMの対応力も上がります。

**⑤文脈の提供**  
初期プロンプトだけでなく、既存コード、モックアップ、APIの仕様、セキュリティ要件など、必要な文脈を丁寧に伝えることで、LLMの提案が現場にフィットしたものになります。

![](https://ai-data-base.com/wp-content/uploads/2025/05/AIDB_90427_2-1024x604.png)

Vibe Codingで求められる基本スキル 考える力、ツールの使い方、段階的な確認、問題発見、文脈の理解を整理

#### 相互作用のパターン

Vibe Codingでは、プロンプトと応答のサイクルを素早く回しながら開発を進めます。初期の高レベルなリクエストから始まり、LLMが出したコードをレビューし、必要に応じてプロンプトを修正したり、手を加えたりしながらブラッシュアップしていきます。この反復によって、プロトタイプの立ち上げや新しい試みの検証がスムーズになります。

### 自律的なエージェントによる開発をAgentic Codingと呼ぶ

Vibe CodingがLLMとの協働を重視するのに対し、より高い自律性を持つシステムに開発の実行を委ねるスタイルをAgentic Codingと呼ぶ流れがあります。

開発者は「外部APIを統合したい」「CIワークフローを構築したい」といった目標だけを指定し、それをもとにエージェントが必要なタスクを判断し、実行します。

この考え方の根底には「任せられることは任せる」という発想があります。開発者は細部の実装から離れ、システム全体を監督する役割へと移っていきます。

#### Agentic Codingの代表例

- OpenAI Codex（コード生成からテスト実行、プルリクエスト生成まで自律的に行う）
- Claude Code（決定 [ノード](https://ai-data-base.com/archives/26470 "ノード") や差分を記録しつつ自律実行できるエージェント）
- Jules（複雑なマルチステップタスクを分解して自動実行するGoogle製エージェント）
- Microsoft AutoGen（高レベル目標からサブタスクを自律的に計画・実行するフレームワーク）
- Crew AI（企業向けにタスクの自動化を支援するエージェント型プラットフォーム）
- LangChain Agents（LLMを中心に複数のエージェントを連携させるライブラリ）
- Devin（自然言語指示に基づき開発工程全体を自動処理するエージェント）

![](https://ai-data-base.com/wp-content/uploads/2025/05/AIDB_90427_4.png)

Julesというエージェントの実行手順 リポジトリを読み取り、コードを書き換え、ドキュメントやGitも自動で更新する流れ

なお、本論文には記載がありませんが、AutoDev（開発タスクの実行・検証・修正を自律的に行う）も実務で広く利用されています。

#### 自律エージェントに求められる能力（人間に求められる能力ではない点に注意）

① **目標の読み取りと解釈**  
自然言語で書かれた目標から、どのファイルや機能が関係するのかを見極めます。たとえば「R1ロボットにGoogle Gemini APIを組み込む」といった要望を、具体的なコード編集につなげる力が求められます。

**②タスクの計画と分解**  
一つの目標を複数のサブタスクに分け、順を追って実行する計画を立てます。APIの調査からコードの挿入、テストまでを一つの流れとして管理します。

③ **外部ツールの活用**  
コードエディタだけでなく、Git、テストツール、外部API、Webブラウザなどを使いこなしながら作業を進める必要があります。

**④反復実行と修正**  
出力がうまくいかなかった場合は、エラーを検出し、必要に応じて自律的に修正と再実行を行います。変更内容の比較や差分の記録なども自動化されます。

⑤ **問題への対応**  
思い通りに動かないケースでは、静的解析や検索、文書の読み取りを行い、問題の特定と解決を試みます。

⑥ **長期的な文脈の保持**  
セッションをまたいで状態を記憶し、過去の指示や設定を踏まえて作業を継続します。変数、APIキー、環境設定などの情報を維持できる仕組みが必要です。

⑦ **自己評価と見直し**  
一連の作業ログをもとに、自らの判断や行動をふりかえり、どこで失敗したかを特定し、次のステップに活かす機能も徐々に実装され始めています。

![](https://ai-data-base.com/wp-content/uploads/2025/05/AIDB_90427_3.png)

Agentic Codingに必要な能力の流れ 目的の理解から自己修正までの一連のスキルを整理

Vibe CodingとAgentic Codingの比較分類を表にすると以下の通りです。

| 側面 | Vibe Coding | Agentic Coding |
| --- | --- | --- |
| コア哲学 | 人とAIが一緒に作業するスタイル。ざっくりした意図を伝えて何度もやりとりしながら進める | ある程度まとまった作業をAIに任せ、人は全体の設計や進捗確認に注力 |
| AIの自律性レベル | 低〜中。細かく指示しながら一緒に作っていく | 中〜高。全体の目標を伝えれば細かい作業はAIが自分で進める |
| 開発者の主な役割 | 指示を出しながら一緒に手を動かすサポーター | 大きな方針を決めてAIの作業を見守るマネージャー |
| インタラクションモデル | やりとりを重ねながら部分的に修正していく | はじめに指示して、あとは進捗を見ながら必要な時だけ関与する |
| 計画・タスク分解 | 人がやる。小さい作業に分けてAIに頼む | AIがやる。全体を見て自分で計画を立てて進める |
| ツール利用 | コード作成が中心。Gitなどは人が操作 | テストやGit操作などもAIが担当 |
| 実行環境 | 手元のIDEなどで人が実行 | AIがサンドボックス内で自動的に実行 |
| エラー検出・対応 | 人がテストやレビューで見つけ、AIに直させる | 自動でエラーを見つけて、直してやり直す |
| タスク範囲 | 関数やUIパーツ、ちょっとしたテストや整理など | 機能全体の構築、大規模整理、CI/CDの構築など |
| コンテキスト管理 | 今の会話やドキュメントを中心に把握。長期記憶は人が補う | ベクトル検索などを使って、過去の状況も覚えておける |
| 主なアウトプット | 部分的なコードやモジュールを出力。人が仕上げる | テストや設定も含めた完成度の高い成果物を生成 |
| 成熟度と普及状況 | 多くのIDEやサービスで利用中（GitHub Copilotなど） | 一部の研究プロジェクトや実験環境で活用が進行中（AutoGenなど） |

Vibe Codingは既に市民権を得つつある一方で、Agentic Codingは知名度が相対的に低く、まだ浸透していないのが現状です。技術的な成熟度も影響しているかもしれません。

## 技術的な仕組みと動作の違い

Vibe CodingとAgentic Codingは、どちらもLLMを活用するスタイルですが、その動かし方や仕組みには大きな違いがあります。ツールの設計思想、実行モデル、フィードバックの取り方、安全性の確保まで、それぞれ別のアプローチが取られています。

こうした違いを理解しておくと、自社の開発環境や目的に応じて、どちらを取り入れるべきかが見えてきます。

### 実行のしかたと使われる技術

#### Vibe Codingは軽量な対話ベース

Vibe Codingで使われるツールは、IDEやブラウザ上のエディタなど、比較的軽量な仕組みが中心です。LLMはコードを生成するだけで、実行やテストは開発者自身が行います。

生成されたコードは手元の環境にコピーして動かす必要があり、テストケースも自分で用意します。つまり、コードの生成と実行が分かれていて、フィードバックを得るにはひと手間かかる構造です。

その分、柔軟性が高く、試行錯誤しながら開発する場面や、早い段階でアイデアを形にしたいプロトタイピングなどに向いています。ただし、繰り返し検証が必要になる場面では、開発者の負担がやや大きくなります。

#### 一方でAgentic Codingは実行環境まで一体化

Agentic Codingでは、コードを作るだけでなく、エージェントが自分でそれを動かして確認するところまで含まれています。たとえば、DockerやWASM、QEMUなどを使って実行環境そのものを内蔵しており、そこでコードを試したうえで、必要があれば自動的に修正します。

開発者がいちいち実行結果を見て判断せず、エージェントがログや出力を読み取りながら、タスクを繰り返し改善していきます。安全性を担保する場合は、メモリやネットワークのアクセスも、サンドボックスによってきちんと制限されている必要があります。

### フィードバックと自律性の設計

#### Vibe Codingは人間が主導して進める

Vibe Codingでは、コードの良し悪しを判断したり、エラーの原因を突き止めたりするのは基本的に人間です。LLMはプロンプトに応じてコードを出すだけで、出力が正しいかどうかを自分で判断する力はありません。

そのため、開発者は「こうしてほしい」という意図をうまく伝える力に加えて、出てきたコードを自分でテストし、必要に応じてプロンプトを修正することが求められます。試行錯誤の自由度が高い一方で、手間や判断の負荷もそれなりにかかります。

#### Agentic Codingは目標をもとに自律的に進む

Agentic Codingでは、基本的には人間は「何を作るか」だけ決めて、そこから先はエージェントが自分で考えて進めていくという考え方です。コードの作成、実行、テスト、失敗時の対応まで、すべて一連のループの中で完結します。

たとえば「ユーザー分析用のダッシュボードを作る」と伝えた場合は、エージェントはデータベースの構成を考え、クエリを設計し、画面をつなぎ、テストして問題があれば直すところまでやります。途中で止まらずに作業を進められるのが強みです。

Vibe CodingとAgentic Codingシステムの [アーキテクチャ](https://ai-data-base.com/archives/26562 "アーキテクチャ") 比較をまとめると以下の表になります。

| [アーキテクチャ](https://ai-data-base.com/archives/26562 "アーキテクチャ") 要素 | Vibe Coding | Agentic Coding |
| --- | --- | --- |
| システム制御 | プラグインやUIが中心。人が操作して1回ずつ動かす | 計画役と実行役のエージェントが連携して、作業を自動で続ける |
| プロンプト処理 | その場の会話で使うプロンプトをUIが管理 | 目標の意味を解釈して記憶し、タスクを整理して実行 |
| メモリ・コンテキスト | 直近のプロンプトが中心で、長期記憶はあまり使わない | 長期記憶や外部知識ベースを活用し、前の情報も活かせる |
| 実行エンジン | AIはコードを出すだけで、実行は人が手動 | AIが自分でコードを動かし、コンパイルやブラウザ操作も行う |
| マルチエージェント連携 | コード生成など一部に特化した小さなAIだけで、連携はあまりしない | 各分野のAIが分担し、連携して全体の作業を行う |
| ツールとの連携 | Gitなどの操作は人が実行 | AIがコミットやAPI操作なども自動で実行 |
| テストと検証 | テストコードをAIが提案し、人が実行 | 自分でテストして、結果に応じてやり直す仕組みを持つ |
| セキュリティ管理 | 基本は後から人がチェック | 実行時にアクセス制御などを自動で適用 |
| 見える化 | ログやIDEで軽く把握できる程度 | 例外やメトリクスを集めて改善に活かす |
| デプロイとCI/CD | デプロイは手動設定、CI/CDは外部サービスと連携 | 自動でCI/CDを作り、デプロイやロールバックも管理 |

![](https://ai-data-base.com/wp-content/uploads/2025/05/AIDB_90427_5-1024x710.png)

両スタイルのシステム構成の比較 エディタ中心のVibe Codingと、全体を管理するAgentic Codingの違い

### 安全性と説明可能性の考え方

#### Vibe Codingは開発者による後追いチェックが必要

Vibe Codingは自由度が高いぶん、安全性の確保は後から行う形になります。生成されたコードに問題がないかは、開発者が手動で確認したり、ESLintやCodeQLなどのツールを使って静的解析を行う必要があります。

また、LLMはその場限りの応答を返すだけなので、なぜそのコードを出したのかといった理由を後から追うのが難しい場合もあります。セキュリティや規制対応が求められる場面では、この点が弱みになりやすいです。

#### Agentic Codingは実行記録が強味　安全対策が重要

Agentic Codingでは、安全性や説明可能性をあらかじめ設計の中に組み込んでおきます。実行環境をきちんと分離し、何をいつ行ったかがログとして記録します。

幾つかのサービスでは、エージェントがどんな決定をしたか、どう推論したかも確認できるようになっていて、あとからチェックすることができます。本番環境への影響を最小限に抑えるためには、問題があった場合に巻き戻せる仕組み（ロールバック）も用意されている必要があります。

それぞれの実行能力と安全性の比較をまとめます。

| 特性 | Agentic Coding | Vibe Coding |
| --- | --- | --- |
| コードの実行方法 | コンテナの中で自動的に実行 | IDEなどで人が手動で実行 |
| テストパイプライン | 失敗したら再実行する自動テストエージェント付き | 人がテストを考え、必要に応じてAIに指示 |
| フィードバックの仕組み | AIが自分で判断してやり直す | 人が見て、問題があればプロンプトで対応 |
| セキュリティ対策 | 実行時に制限や保護をかける | コード生成後にチェックすることが多い |
| 説明のしやすさ | 実行記録や判断のログが残っており追える | 特に記録はなく、記憶やメモに頼ることが多い |
| プロンプトへの反応 | 少し曖昧でも対応できる | 曖昧なプロンプトは誤解や抜けにつながりやすい |
| 得意な使い方 | CI/CDやインフラ構築、大規模な修正など | 試作やUI設計、教育向けなど |

## 実際の使い方とワークフローの違い

Vibe CodingとAgentic Codingは、表面的にはどちらもLLMを活用する開発手法に見えますが、実際には関わり方も作業の進め方も大きく異なります。使い方の違いを知ることで、開発者やチームがどこまで準備しておくべきかが明確になります。

### 開発者の役割の違い

双方における開発者の役割の違いを見ていきます。

Vibe Codingは、開発者がLLMと対話しながら一緒にコードを作るスタイルです。自分の意図を自然言語で伝えながら、出力されたコードの妥当性や方向性を人間が確認しつつ進めます。開発者は次のような立場を取ることになります。

- 意図を言語化する設計者として、目的や制約を明確に伝える
- 生成されたコードの方向性を調整する監督者として、デザインや動作を確認する
- LLMを試しながら組み合わせを探る実験者として、柔軟に動く

試行錯誤の自由度が高いため、プロトタイピングや新機能の発想には適していますが、LLMが出力するコードにはばらつきがあるため、品質管理には人間の目が欠かせません。

一方でAgentic Codingでは、開発者はタスクの設計や意図の明示に集中します。細かな実装はエージェントに任せ、ログや中間成果を見ながら調整する役割です。

- タスクや要件を定義する計画者として、全体像を把握して構成する
- エージェントの挙動を見守る監督者として、流れの妥当性を判断する
- 出力された成果物に対して品質を担保する保証者として、問題がないか検証する

全体を俯瞰する力が求められる一方で、エージェントに依存しすぎると自分で細かいコードの意味を追えなくなるリスクもあります。実装内容がブラックボックス化しやすい点は注意が必要です。

### ワークフローの進め方の違い

次にワークフローの進め方の違いを見ていきます。

Vibe Codingでは、会話のキャッチボールを繰り返しながら進めていきます。曖昧なアイデアでも、まずは投げてみて、LLMからの返答を受けて軌道修正するような流れです。

たとえば、UIのダッシュボードを作る場合、「売上や解約率のグラフが欲しい」と伝え、出てきたコードを確認しながら「CSVダウンロードも追加したい」「ツールチップも入れて」などと要望を追加していきます。

こうしたやり取りはスピーディですが、タスク全体を整理しきれていないまま始めてしまうと、実装の一貫性が崩れやすい傾向があります。

一方でAgentic Codingでは、より構造化されたステップで作業が進みます。たとえば「依存ライブラリを安全なバージョンに更新してほしい」と指示して、エージェントにはパッケージの更新、テストの実行、ログの記録、変更内容の整備まで一通り処理させます。

自動的にタスクが完結する反面、途中で判断ミスが起きるとそれが連鎖し、まとめて修正するのが難しくなる場合もあります。事後確認やモニタリング体制が不可欠です。

### 生産性や認知的な負荷への影響

また、生産性や認知的な負荷への影響にも違いがあります。

Vibe Codingは、コードの細部に意識を向けずに済むため、思考の流れを妨げにくいという利点があります。アイデア出しや初学者のサポートに適していますが、知らず知らずのうちにプログラミングの基礎力が落ちる可能性もあります。

一方のAgentic Codingは、複雑な処理を任せられるぶん、開発者に求められる知識のレベルも上がります。生成された成果物の正しさを自分で判断できないと、プロジェクト全体の信頼性に関わることもあります。

### チームで使う場合のポイント

最後に、チームで使う場合のポイントの違いについて。

Vibe Codingは、少人数での開発やアイデアのブレストのような場面に向いています。複数人でLLMと交互にやり取りしながら進めることも可能です。

他方、Agentic Codingは、大規模なシステムや明確に分割できるタスクがあるチームに適しています。タスクごとに異なるエージェントに任せて、パイプラインとして連携させることができるため、並列性や再現性を重視する体制と相性がよくなります。

ただし、どちらの場合も、導入前にメンバーの習熟度や補助的な管理ツールの整備状況を見極める必要があります。技術の導入自体が目的にならないよう、適切な活用の前提条件を確認しておくことが求められます。

開発者の役割とワークフローの比較を表にまとめます。

| 項目 | Vibe Coding | Agentic Coding |
| --- | --- | --- |
| 開発者の役割 | アイデアを出し、AIと一緒に手を動かす | 計画を立てて、AIの動きを見守る |
| ワークフローの特徴 | 柔軟で会話的 | 構造的で繰り返し型 |
| やりとりのしかた | 話しかけて反応を見ながら修正 | 目標を伝えてAIに任せ、進捗を見て対応 |
| 向いている場面 | プロトタイプ制作やデザイン | 修正や運用、品質チェックなど |
| 学習のしやすさ | 自然言語なので始めやすい | エージェントの仕組み理解が必要 |
| テストの扱い | 人が考えて、必要ならAIに作らせる | AIが自動で作成し実行まで行う |
| ドキュメント生成 | 必要なときにAIに頼む | 作業中に自動で記録する |
| エラー対応の主導 | 人が判断して対応 | AIが自動で修正ややり直しを行う |

## 後編に続きます。

**参照文献情報**

- タイトル：Vibe Coding vs. Agentic Coding: Fundamentals and Practical Implications of Agentic AI
- URL： [https://doi.org/10.48550/arXiv.2505.19443](https://doi.org/10.48550/arXiv.2505.19443)
- 著者：Ranjan Sapkota, Konstantinos I. Roumeliotis, Manoj Karkee
- 所属：Cornell University, University of the Peloponnese

**■サポートのお願い  
**AIDBを便利だと思っていただけた方に、任意の金額でサポートしていただけますと幸いです。  

  

[言語学の観点から導くプロンプト構造の分類フレームワーク　LLMの性能に与える影響の定量評価](https://ai-data-base.com/archives/90134)

[Vibe CodingとAgentic Codingの現在地【後編】～それぞれの活用ケース～](https://ai-data-base.com/archives/90483)

 [![](https://ai-data-base.com/wp-content/themes/innovate_hack_tcd025/img/footer/return_top.png) PAGE TOP](https://ai-data-base.com/archives/#header_top)